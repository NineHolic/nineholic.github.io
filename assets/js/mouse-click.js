class Circle { constructor({ origin: s, speed: a, color: r, angle: c, context: t }) { this.origin = s, this.position = { ...this.origin }, this.color = r, this.speed = a, this.angle = c, this.context = t, this.renderCount = 0 } draw() { this.context.fillStyle = this.color, this.context.beginPath(), this.context.arc(this.position.x, this.position.y, 2, 0, 2 * Math.PI), this.context.fill() } move() { this.position.x = Math.sin(this.angle) * this.speed + this.position.x, this.position.y = Math.cos(this.angle) * this.speed + this.position.y + .3 * this.renderCount, this.renderCount++ } } class Boom { constructor({ origin: s, context: a, circleCount: r = 10, area: c }) { this.origin = s, this.context = a, this.circleCount = r, this.area = c, this.stop = !1, this.circles = [] } randomArray(s) { return s[Math.floor(s.length * Math.random())] } randomColor() { const s = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F']; return '#' + this.randomArray(s) + this.randomArray(s) + this.randomArray(s) + this.randomArray(s) + this.randomArray(s) + this.randomArray(s) } randomRange(s, a) { return (a - s) * Math.random() + s } init() { for (let s = 0; s < this.circleCount; s++) { const a = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }); this.circles.push(a) } } move() { this.circles.forEach((s, a) => { s.position.x > this.area.width || s.position.y > this.area.height ? this.circles.splice(a, 1) : s.move() }), 0 == this.circles.length && (this.stop = !0) } draw() { this.circles.forEach(s => s.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement("canvas"), this.renderCanvas = document.createElement("canvas"), this.computerContext = this.computerCanvas.getContext("2d"), this.renderContext = this.renderCanvas.getContext("2d"), this.globalWidth = window.innerWidth, this.globalHeight = window.innerHeight, this.booms = [], this.running = !1 } handleMouseDown(s) { const a = new Boom({ origin: { x: s.clientX, y: s.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }); a.init(), this.booms.push(a), this.running || this.run() } handlePageHide() { this.booms = [], this.running = !1 } init() { const s = this.renderCanvas.style; s.position = "fixed", s.top = s.left = "0", s.zIndex = "999999999999999999999999999999999999999999", s.pointerEvents = "none", s.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth, s.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight, document.body.append(this.renderCanvas), window.addEventListener("mousedown", this.handleMouseDown.bind(this)), window.addEventListener("pagehide", this.handlePageHide.bind(this)) } run() { if (this.running = !0, 0 == this.booms.length) return this.running = !1; requestAnimationFrame(this.run.bind(this)), this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight), this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight), this.booms.forEach((s, a) => { s.stop ? this.booms.splice(a, 1) : (s.move(), s.draw()) }), this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects; cursorSpecialEffects.init();